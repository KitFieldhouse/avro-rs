// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

use crate::resolving::{ResolvedNode, ResolvedRecord};
use crate::schema::{InnerDecimalSchema, UuidSchema};
use crate::{
    AvroResult, Error,
    bigdecimal::deserialize_big_decimal,
    decimal::Decimal,
    duration::Duration,
    error::Details,
    schema::{
        DecimalSchema, EnumSchema, FixedSchema, Name, Namespace, RecordSchema,
        Schema,
    },
    resolving::{ResolvedSchema},
    types::Value,
    util::{safe_len, zag_i32, zag_i64},
};
use std::{
    borrow::Borrow,
    collections::HashMap,
    io::{ErrorKind, Read},
};
use uuid::Uuid;

#[inline]
pub(crate) fn decode_long<R: Read>(reader: &mut R) -> AvroResult<Value> {
    zag_i64(reader).map(Value::Long)
}

#[inline]
fn decode_int<R: Read>(reader: &mut R) -> AvroResult<Value> {
    zag_i32(reader).map(Value::Int)
}

#[inline]
pub(crate) fn decode_len<R: Read>(reader: &mut R) -> AvroResult<usize> {
    let len = zag_i64(reader)?;
    safe_len(usize::try_from(len).map_err(|e| Details::ConvertI64ToUsize(e, len))?)
}

/// Decode the length of a sequence.
///
/// Maps and arrays are 0-terminated, 0i64 is also encoded as 0 in Avro reading a length of 0 means
/// the end of the map or array.
fn decode_seq_len<R: Read>(reader: &mut R) -> AvroResult<usize> {
    let raw_len = zag_i64(reader)?;
    safe_len(
        usize::try_from(match raw_len.cmp(&0) {
            std::cmp::Ordering::Equal => return Ok(0),
            std::cmp::Ordering::Less => {
                let _size = zag_i64(reader)?;
                raw_len.checked_neg().ok_or(Details::IntegerOverflow)?
            }
            std::cmp::Ordering::Greater => raw_len,
        })
        .map_err(|e| Details::ConvertI64ToUsize(e, raw_len))?,
    )
}

/// Decode a `Value` from avro format given its `Schema`.
/// This function will always convert the supplied schema into a ResolvedSchema which
/// may cuase performance concerns. Consider using decode_complete.
pub fn decode<R: Read>(schema: &Schema, reader: &mut R) -> AvroResult<Value> {
    let resolved : ResolvedSchema = schema.clone().try_into()?;
    decode_complete(&resolved, reader)
}


/// Decode a `Value` from avro format given its `Schema`.
pub fn decode_complete<R: Read>(resolved_schema: &ResolvedSchema, reader: &mut R) -> AvroResult<Value> {
    decode_internal(ResolvedNode::new(&resolved_schema), reader)
}

pub(crate) fn decode_internal<R: Read>(
    node: ResolvedNode,
    reader: &mut R
) -> AvroResult<Value> {
    match node {
        ResolvedNode::Null => Ok(Value::Null),
        ResolvedNode::Boolean => {
            let mut buf = [0u8; 1];
            match reader.read_exact(&mut buf[..]) {
                Ok(_) => match buf[0] {
                    0u8 => Ok(Value::Boolean(false)),
                    1u8 => Ok(Value::Boolean(true)),
                    _ => Err(Details::BoolValue(buf[0]).into()),
                },
                Err(io_err) => {
                    if let ErrorKind::UnexpectedEof = io_err.kind() {
                        Ok(Value::Null)
                    } else {
                        Err(Details::ReadBoolean(io_err).into())
                    }
                }
            }
        }
        ResolvedNode::Decimal(DecimalSchema { inner, .. }) => match inner {
            InnerDecimalSchema::Fixed(fixed) => {
                match decode_internal(
                    ResolvedNode::Fixed(&fixed.copy_only_size()),
                    reader
                )? {
                    Value::Fixed(_, bytes) => Ok(Value::Decimal(Decimal::from(bytes))),
                    value => Err(Details::FixedValue(value).into()),
                }
            }
            InnerDecimalSchema::Bytes => {
                match decode_internal(ResolvedNode::Bytes, reader)? {
                    Value::Bytes(bytes) => Ok(Value::Decimal(Decimal::from(bytes))),
                    value => Err(Details::BytesValue(value).into()),
                }
            }
        },
        ResolvedNode::BigDecimal => {
            match decode_internal(ResolvedNode::Bytes, reader)? {
                Value::Bytes(bytes) => deserialize_big_decimal(&bytes).map(Value::BigDecimal),
                value => Err(Details::BytesValue(value).into()),
            }
        }
        ResolvedNode::Uuid(UuidSchema::String) => {
            let Value::String(string) =
                decode_internal(ResolvedNode::String, reader)?
            else {
                // decoding a String can also return a Null, indicating EOF
                return Err(Error::new(Details::ReadBytes(std::io::Error::from(
                    ErrorKind::UnexpectedEof,
                ))));
            };
            let uuid = Uuid::parse_str(&string).map_err(Details::ConvertStrToUuid)?;
            Ok(Value::Uuid(uuid))
        }
        ResolvedNode::Uuid(UuidSchema::Bytes) => {
            let Value::Bytes(bytes) =
                decode_internal(ResolvedNode::Bytes, reader)?
            else {
                unreachable!(
                    "decode_internal(Schema::Bytes) can only return a Value::Bytes or an error"
                )
            };
            let uuid = Uuid::from_slice(&bytes).map_err(Details::ConvertSliceToUuid)?;
            Ok(Value::Uuid(uuid))
        }
        ResolvedNode::Uuid(UuidSchema::Fixed(fixed)) => {
            let Value::Fixed(n, bytes) = decode_internal(
                ResolvedNode::Fixed(&fixed.copy_only_size()),
                reader
            )?
            else {
                unreachable!(
                    "decode_internal(Schema::Fixed) can only return a Value::Fixed or an error"
                )
            };
            if n != 16 {
                return Err(Details::ConvertFixedToUuid(n).into());
            }
            let uuid = Uuid::from_slice(&bytes).map_err(Details::ConvertSliceToUuid)?;
            Ok(Value::Uuid(uuid))
        }
        ResolvedNode::Int => decode_int(reader),
        ResolvedNode::Date => zag_i32(reader).map(Value::Date),
        ResolvedNode::TimeMillis => zag_i32(reader).map(Value::TimeMillis),
        ResolvedNode::Long => decode_long(reader),
        ResolvedNode::TimeMicros => zag_i64(reader).map(Value::TimeMicros),
        ResolvedNode::TimestampMillis => zag_i64(reader).map(Value::TimestampMillis),
        ResolvedNode::TimestampMicros => zag_i64(reader).map(Value::TimestampMicros),
        ResolvedNode::TimestampNanos => zag_i64(reader).map(Value::TimestampNanos),
        ResolvedNode::LocalTimestampMillis => zag_i64(reader).map(Value::LocalTimestampMillis),
        ResolvedNode::LocalTimestampMicros => zag_i64(reader).map(Value::LocalTimestampMicros),
        ResolvedNode::LocalTimestampNanos => zag_i64(reader).map(Value::LocalTimestampNanos),
        ResolvedNode::Duration(fixed_schema) => {
            if fixed_schema.size == 12 {
                let mut buf = [0u8; 12];
                reader.read_exact(&mut buf).map_err(Details::ReadDuration)?;
                Ok(Value::Duration(Duration::from(buf)))
            } else {
                Err(Details::CompareFixedSizes {
                    size: 12,
                    n: fixed_schema.size,
                }
                .into())
            }
        }
        ResolvedNode::Float => {
            let mut buf = [0u8; std::mem::size_of::<f32>()];
            reader
                .read_exact(&mut buf[..])
                .map_err(Details::ReadFloat)?;
            Ok(Value::Float(f32::from_le_bytes(buf)))
        }
        ResolvedNode::Double => {
            let mut buf = [0u8; std::mem::size_of::<f64>()];
            reader
                .read_exact(&mut buf[..])
                .map_err(Details::ReadDouble)?;
            Ok(Value::Double(f64::from_le_bytes(buf)))
        }
        ResolvedNode::Bytes => {
            let len = decode_len(reader)?;
            let mut buf = vec![0u8; len];
            reader.read_exact(&mut buf).map_err(Details::ReadBytes)?;
            Ok(Value::Bytes(buf))
        }
        ResolvedNode::String => {
            let len = decode_len(reader)?;
            let mut buf = vec![0u8; len];
            match reader.read_exact(&mut buf) {
                Ok(_) => Ok(Value::String(
                    String::from_utf8(buf).map_err(Details::ConvertToUtf8)?,
                )),
                Err(io_err) => {
                    if let ErrorKind::UnexpectedEof = io_err.kind() {
                        Ok(Value::Null)
                    } else {
                        Err(Details::ReadString(io_err).into())
                    }
                }
            }
        }
        ResolvedNode::Fixed(FixedSchema { size, .. }) => {
            let mut buf = vec![0u8; *size];
            reader
                .read_exact(&mut buf)
                .map_err(|e| Details::ReadFixed(e, *size))?;
            Ok(Value::Fixed(*size, buf))
        }
        ResolvedNode::Array(inner) => {
            let mut items = Vec::new();

            loop {
                let len = decode_seq_len(reader)?;
                if len == 0 {
                    break;
                }

                items.reserve(len);
                for _ in 0..len {
                    items.push(decode_internal(
                        inner.resolve_items(),
                        reader
                    )?);
                }
            }

            Ok(Value::Array(items))
        }
        ResolvedNode::Map(inner) => {
            let mut items = HashMap::new();

            loop {
                let len = decode_seq_len(reader)?;
                if len == 0 {
                    break;
                }

                items.reserve(len);
                for _ in 0..len {
                    match decode_internal(ResolvedNode::String, reader)? {
                        Value::String(key) => {
                            let value =
                                decode_internal(inner.resolve_types(), reader)?;
                            items.insert(key, value);
                        }
                        value => return Err(Details::MapKeyType(value.into()).into()),
                    }
                }
            }

            Ok(Value::Map(items))
        }
        ResolvedNode::Union(inner) => match zag_i64(reader).map_err(Error::into_details) {
            Ok(index) => {
                let variants = inner.resolve_schemas();
                let variant = variants
                    .get(usize::try_from(index).map_err(|e| Details::ConvertI64ToUsize(e, index))?)
                    .ok_or(Details::GetUnionVariant {
                        index,
                        num_variants: variants.len(),
                    })?;
                let value = decode_internal(variant.clone(), reader)?;
                Ok(Value::Union(index as u32, Box::new(value)))
            }
            Err(Details::ReadVariableIntegerBytes(io_err)) => {
                if let ErrorKind::UnexpectedEof = io_err.kind() {
                    Ok(Value::Union(0, Box::new(Value::Null)))
                } else {
                    Err(Details::ReadVariableIntegerBytes(io_err).into())
                }
            }
            Err(io_err) => Err(Error::new(io_err)),
        },
        ResolvedNode::Record(ResolvedRecord {fields, .. }) => {
            // Benchmarks indicate ~10% improvement using this method.
            let mut items = Vec::with_capacity(fields.len());
            for field in fields {
                // TODO: This clone is also expensive. See if we can do away with it...
                items.push((
                    field.name.clone(),
                    decode_internal(
                        field.resolve_field(),
                        reader,
                    )?,
                ));
            }
            Ok(Value::Record(items))
        }
        ResolvedNode::Enum(EnumSchema { symbols, .. }) => {
            Ok(if let Value::Int(raw_index) = decode_int(reader)? {
                let index = usize::try_from(raw_index)
                    .map_err(|e| Details::ConvertI32ToUsize(e, raw_index))?;
                if (0..symbols.len()).contains(&index) {
                    let symbol = symbols[index].clone();
                    Value::Enum(raw_index as u32, symbol)
                } else {
                    return Err(Details::GetEnumValue {
                        index,
                        nsymbols: symbols.len(),
                    }
                    .into());
                }
            } else {
                return Err(Details::GetEnumUnknownIndexValue.into());
            })
        }
    }
}

#[cfg(test)]
#[allow(clippy::expect_fun_call)]
mod tests {
    use crate::schema::{InnerDecimalSchema, UuidSchema};
    use crate::{
        decode::decode, encode::{encode, tests::success}, schema::{DecimalSchema, FixedSchema, Name, Schema}, types::Value::{self, Array, Int, Map}, Decimal
    };
    use apache_avro_test_helper::TestResult;
    use pretty_assertions::assert_eq;
    use std::collections::HashMap;
    use uuid::Uuid;

    #[test]
    fn test_decode_array_without_size() -> TestResult {
        let mut input: &[u8] = &[6, 2, 4, 6, 0];
        let result = decode(&Schema::array(Schema::Int), &mut input);
        assert_eq!(Array(vec!(Int(1), Int(2), Int(3))), result?);

        Ok(())
    }

    #[test]
    fn test_decode_array_with_size() -> TestResult {
        let mut input: &[u8] = &[5, 6, 2, 4, 6, 0];
        let result = decode(&Schema::array(Schema::Int), &mut input);
        assert_eq!(Array(vec!(Int(1), Int(2), Int(3))), result?);

        Ok(())
    }

    #[test]
    fn test_decode_map_without_size() -> TestResult {
        let mut input: &[u8] = &[0x02, 0x08, 0x74, 0x65, 0x73, 0x74, 0x02, 0x00];
        let result = decode(&Schema::map(Schema::Int), &mut input);
        let mut expected = HashMap::new();
        expected.insert(String::from("test"), Int(1));
        assert_eq!(Map(expected), result?);

        Ok(())
    }

    #[test]
    fn test_decode_map_with_size() -> TestResult {
        let mut input: &[u8] = &[0x01, 0x0C, 0x08, 0x74, 0x65, 0x73, 0x74, 0x02, 0x00];
        let result = decode(&Schema::map(Schema::Int), &mut input);
        let mut expected = HashMap::new();
        expected.insert(String::from("test"), Int(1));
        assert_eq!(Map(expected), result?);

        Ok(())
    }

    #[test]
    fn test_negative_decimal_value() -> TestResult {
        use crate::{encode::encode, schema::Name};
        use num_bigint::ToBigInt;
        let schema = Schema::Decimal(DecimalSchema {
            inner: InnerDecimalSchema::Fixed(
                FixedSchema::builder()
                    .name(Name::new("decimal")?.into())
                    .size(2)
                    .build(),
            ),
            precision: 4,
            scale: 2,
        });
        let bigint = (-423).to_bigint().unwrap();
        let value = Value::Decimal(Decimal::from(bigint.to_signed_bytes_be()));

        let mut buffer = Vec::new();
        encode(&value, &schema, &mut buffer).expect(&success(&value, &schema));

        let mut bytes = &buffer[..];
        let result = decode(&schema, &mut bytes)?;
        assert_eq!(result, value);

        Ok(())
    }

    #[test]
    fn test_decode_decimal_with_bigger_than_necessary_size() -> TestResult {
        use crate::{encode::encode, schema::Name};
        use num_bigint::ToBigInt;
        let schema = Schema::Decimal(DecimalSchema {
            inner: InnerDecimalSchema::Fixed(FixedSchema {
                size: 13,
                name: Name::new("decimal")?.into(),
                aliases: None,
                doc: None,
                default: None,
                attributes: Default::default(),
            }),
            precision: 4,
            scale: 2,
        });
        let value = Value::Decimal(Decimal::from(
            ((-423).to_bigint().unwrap()).to_signed_bytes_be(),
        ));
        let mut buffer = Vec::<u8>::new();

        encode(&value, &schema, &mut buffer).expect(&success(&value, &schema));
        let mut bytes: &[u8] = &buffer[..];
        let result = decode(&schema, &mut bytes)?;
        assert_eq!(result, value);

        Ok(())
    }

    #[test]
    fn test_avro_3448_recursive_definition_decode_union() -> TestResult {
        // if encoding fails in this test check the corresponding test in encode
        let schema = Schema::parse_str(
            r#"
        {
            "type":"record",
            "name":"TestStruct",
            "fields": [
                {
                    "name":"a",
                    "type":[ "null", {
                        "type":"record",
                        "name": "Inner",
                        "fields": [ {
                            "name":"z",
                            "type":"int"
                        }]
                    }]
                },
                {
                    "name":"b",
                    "type":"Inner"
                }
            ]
        }"#,
        )?;

        let inner_value1 = Value::Record(vec![("z".into(), Value::Int(3))]);
        let inner_value2 = Value::Record(vec![("z".into(), Value::Int(6))]);
        let outer_value1 = Value::Record(vec![
            ("a".into(), Value::Union(1, Box::new(inner_value1))),
            ("b".into(), inner_value2.clone()),
        ]);
        let mut buf = Vec::new();
        encode(&outer_value1, &schema, &mut buf).expect(&success(&outer_value1, &schema));
        assert!(!buf.is_empty());
        let mut bytes = &buf[..];
        assert_eq!(
            outer_value1,
            decode(&schema, &mut bytes).expect(&format!(
                "Failed to decode using recursive definitions with schema:\n {:?}\n",
                &schema
            ))
        );

        let mut buf = Vec::new();
        let outer_value2 = Value::Record(vec![
            ("a".into(), Value::Union(0, Box::new(Value::Null))),
            ("b".into(), inner_value2),
        ]);
        encode(&outer_value2, &schema, &mut buf).expect(&success(&outer_value2, &schema));
        let mut bytes = &buf[..];
        assert_eq!(
            outer_value2,
            decode(&schema, &mut bytes).expect(&format!(
                "Failed to decode using recursive definitions with schema:\n {:?}\n",
                &schema
            ))
        );

        Ok(())
    }

    #[test]
    fn test_avro_3448_recursive_definition_decode_array() -> TestResult {
        let schema = Schema::parse_str(
            r#"
        {
            "type":"record",
            "name":"TestStruct",
            "fields": [
                {
                    "name":"a",
                    "type":{
                        "type":"array",
                        "items": {
                            "type":"record",
                            "name": "Inner",
                            "fields": [ {
                                "name":"z",
                                "type":"int"
                            }]
                        }
                    }
                },
                {
                    "name":"b",
                    "type": "Inner"
                }
            ]
        }"#,
        )?;

        let inner_value1 = Value::Record(vec![("z".into(), Value::Int(3))]);
        let inner_value2 = Value::Record(vec![("z".into(), Value::Int(6))]);
        let outer_value = Value::Record(vec![
            ("a".into(), Value::Array(vec![inner_value1])),
            ("b".into(), inner_value2),
        ]);
        let mut buf = Vec::new();
        encode(&outer_value, &schema, &mut buf).expect(&success(&outer_value, &schema));
        let mut bytes = &buf[..];
        assert_eq!(
            outer_value,
            decode(&schema, &mut bytes).expect(&format!(
                "Failed to decode using recursive definitions with schema:\n {:?}\n",
                &schema
            ))
        );

        Ok(())
    }

    #[test]
    fn test_avro_3448_recursive_definition_decode_map() -> TestResult {
        let schema = Schema::parse_str(
            r#"
        {
            "type":"record",
            "name":"TestStruct",
            "fields": [
                {
                    "name":"a",
                    "type":{
                        "type":"map",
                        "values": {
                            "type":"record",
                            "name": "Inner",
                            "fields": [ {
                                "name":"z",
                                "type":"int"
                            }]
                        }
                    }
                },
                {
                    "name":"b",
                    "type": "Inner"
                }
            ]
        }"#,
        )?;

        let inner_value1 = Value::Record(vec![("z".into(), Value::Int(3))]);
        let inner_value2 = Value::Record(vec![("z".into(), Value::Int(6))]);
        let outer_value = Value::Record(vec![
            (
                "a".into(),
                Value::Map(vec![("akey".into(), inner_value1)].into_iter().collect()),
            ),
            ("b".into(), inner_value2),
        ]);
        let mut buf = Vec::new();
        encode(&outer_value, &schema, &mut buf).expect(&success(&outer_value, &schema));
        let mut bytes = &buf[..];
        assert_eq!(
            outer_value,
            decode(&schema, &mut bytes).expect(&format!(
                "Failed to decode using recursive definitions with schema:\n {:?}\n",
                &schema
            ))
        );

        Ok(())
    }

    #[test]
    fn test_avro_3448_proper_multi_level_decoding_middle_namespace() -> TestResult {
        // if encoding fails in this test check the corresponding test in encode
        let schema = r#"
        {
          "name": "record_name",
          "namespace": "space",
          "type": "record",
          "fields": [
            {
              "name": "outer_field_1",
              "type": [
                        "null",
                        {
                            "type": "record",
                            "name": "middle_record_name",
                            "namespace":"middle_namespace",
                            "fields":[
                                {
                                    "name":"middle_field_1",
                                    "type":[
                                        "null",
                                        {
                                            "type":"record",
                                            "name":"inner_record_name",
                                            "fields":[
                                                {
                                                    "name":"inner_field_1",
                                                    "type":"double"
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
            },
            {
                "name": "outer_field_2",
                "type" : "middle_namespace.inner_record_name"
            }
          ]
        }
        "#;
        let schema = Schema::parse_str(schema)?;
        let inner_record = Value::Record(vec![("inner_field_1".into(), Value::Double(5.4))]);
        let middle_record_variation_1 = Value::Record(vec![(
            "middle_field_1".into(),
            Value::Union(0, Box::new(Value::Null)),
        )]);
        let middle_record_variation_2 = Value::Record(vec![(
            "middle_field_1".into(),
            Value::Union(1, Box::new(inner_record.clone())),
        )]);
        let outer_record_variation_1 = Value::Record(vec![
            (
                "outer_field_1".into(),
                Value::Union(0, Box::new(Value::Null)),
            ),
            ("outer_field_2".into(), inner_record.clone()),
        ]);
        let outer_record_variation_2 = Value::Record(vec![
            (
                "outer_field_1".into(),
                Value::Union(1, Box::new(middle_record_variation_1)),
            ),
            ("outer_field_2".into(), inner_record.clone()),
        ]);
        let outer_record_variation_3 = Value::Record(vec![
            (
                "outer_field_1".into(),
                Value::Union(1, Box::new(middle_record_variation_2)),
            ),
            ("outer_field_2".into(), inner_record),
        ]);

        let mut buf = Vec::new();
        encode(&outer_record_variation_1, &schema, &mut buf)
            .expect(&success(&outer_record_variation_1, &schema));
        let mut bytes = &buf[..];
        assert_eq!(
            outer_record_variation_1,
            decode(&schema, &mut bytes).expect(&format!(
                "Failed to Decode with recursively defined namespace with schema:\n {:?}\n",
                &schema
            ))
        );

        let mut buf = Vec::new();
        encode(&outer_record_variation_2, &schema, &mut buf)
            .expect(&success(&outer_record_variation_2, &schema));
        let mut bytes = &buf[..];
        assert_eq!(
            outer_record_variation_2,
            decode(&schema, &mut bytes).expect(&format!(
                "Failed to Decode with recursively defined namespace with schema:\n {:?}\n",
                &schema
            ))
        );

        let mut buf = Vec::new();
        encode(&outer_record_variation_3, &schema, &mut buf)
            .expect(&success(&outer_record_variation_3, &schema));
        let mut bytes = &buf[..];
        assert_eq!(
            outer_record_variation_3,
            decode(&schema, &mut bytes).expect(&format!(
                "Failed to Decode with recursively defined namespace with schema:\n {:?}\n",
                &schema
            ))
        );

        Ok(())
    }

    #[test]
    fn test_avro_3448_proper_multi_level_decoding_inner_namespace() -> TestResult {
        // if encoding fails in this test check the corresponding test in encode
        let schema = r#"
        {
          "name": "record_name",
          "namespace": "space",
          "type": "record",
          "fields": [
            {
              "name": "outer_field_1",
              "type": [
                        "null",
                        {
                            "type": "record",
                            "name": "middle_record_name",
                            "namespace":"middle_namespace",
                            "fields":[
                                {
                                    "name":"middle_field_1",
                                    "type":[
                                        "null",
                                        {
                                            "type":"record",
                                            "name":"inner_record_name",
                                            "namespace":"inner_namespace",
                                            "fields":[
                                                {
                                                    "name":"inner_field_1",
                                                    "type":"double"
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
            },
            {
                "name": "outer_field_2",
                "type" : "inner_namespace.inner_record_name"
            }
          ]
        }
        "#;
        let schema = Schema::parse_str(schema)?;
        let inner_record = Value::Record(vec![("inner_field_1".into(), Value::Double(5.4))]);
        let middle_record_variation_1 = Value::Record(vec![(
            "middle_field_1".into(),
            Value::Union(0, Box::new(Value::Null)),
        )]);
        let middle_record_variation_2 = Value::Record(vec![(
            "middle_field_1".into(),
            Value::Union(1, Box::new(inner_record.clone())),
        )]);
        let outer_record_variation_1 = Value::Record(vec![
            (
                "outer_field_1".into(),
                Value::Union(0, Box::new(Value::Null)),
            ),
            ("outer_field_2".into(), inner_record.clone()),
        ]);
        let outer_record_variation_2 = Value::Record(vec![
            (
                "outer_field_1".into(),
                Value::Union(1, Box::new(middle_record_variation_1)),
            ),
            ("outer_field_2".into(), inner_record.clone()),
        ]);
        let outer_record_variation_3 = Value::Record(vec![
            (
                "outer_field_1".into(),
                Value::Union(1, Box::new(middle_record_variation_2)),
            ),
            ("outer_field_2".into(), inner_record),
        ]);

        let mut buf = Vec::new();
        encode(&outer_record_variation_1, &schema, &mut buf)
            .expect(&success(&outer_record_variation_1, &schema));
        let mut bytes = &buf[..];
        assert_eq!(
            outer_record_variation_1,
            decode(&schema, &mut bytes).expect(&format!(
                "Failed to Decode with recursively defined namespace with schema:\n {:?}\n",
                &schema
            ))
        );

        let mut buf = Vec::new();
        encode(&outer_record_variation_2, &schema, &mut buf)
            .expect(&success(&outer_record_variation_2, &schema));
        let mut bytes = &buf[..];
        assert_eq!(
            outer_record_variation_2,
            decode(&schema, &mut bytes).expect(&format!(
                "Failed to Decode with recursively defined namespace with schema:\n {:?}\n",
                &schema
            ))
        );

        let mut buf = Vec::new();
        encode(&outer_record_variation_3, &schema, &mut buf)
            .expect(&success(&outer_record_variation_3, &schema));
        let mut bytes = &buf[..];
        assert_eq!(
            outer_record_variation_3,
            decode(&schema, &mut bytes).expect(&format!(
                "Failed to Decode with recursively defined namespace with schema:\n {:?}\n",
                &schema
            ))
        );

        Ok(())
    }

    #[test]
    fn avro_3926_encode_decode_uuid_to_string() -> TestResult {
        use crate::encode::encode;

        let schema = Schema::String;
        let value = Value::Uuid(Uuid::parse_str("550e8400-e29b-41d4-a716-446655440000")?);

        let mut buffer = Vec::new();
        encode(&value, &schema, &mut buffer).expect(&success(&value, &schema));

        let result = decode(&Schema::Uuid(UuidSchema::String), &mut &buffer[..])?;
        assert_eq!(result, value);

        Ok(())
    }

    #[test]
    fn avro_3926_encode_decode_uuid_to_fixed() -> TestResult {
        use crate::encode::encode;

        let fixed = FixedSchema {
            size: 16,
            name: Name::new("uuid")?.into(),
            aliases: None,
            doc: None,
            default: None,
            attributes: Default::default(),
        };

        let schema = Schema::Fixed(fixed.clone());
        let value = Value::Uuid(Uuid::parse_str("550e8400-e29b-41d4-a716-446655440000")?);

        let mut buffer = Vec::new();
        encode(&value, &schema, &mut buffer).expect(&success(&value, &schema));

        let result = decode(&Schema::Uuid(UuidSchema::Fixed(fixed)), &mut &buffer[..])?;
        assert_eq!(result, value);

        Ok(())
    }

    #[test]
    fn encode_decode_uuid_to_bytes() -> TestResult {
        use crate::encode::encode;

        let schema = Schema::Bytes;
        let value = Value::Uuid(Uuid::parse_str("550e8400-e29b-41d4-a716-446655440000")?);

        let mut buffer = Vec::new();
        encode(&value, &schema, &mut buffer).expect(&success(&value, &schema));

        let result = decode(&Schema::Uuid(UuidSchema::Bytes), &mut &buffer[..])?;
        assert_eq!(result, value);

        Ok(())
    }
}
